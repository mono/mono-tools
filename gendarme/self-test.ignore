@ mono-options.ignore

# ---------------------------------------------------------
# TODO: These should be fixed.

R: Gendarme.Rules.Correctness.EnsureLocalDisposalRule
M: System.Void Gendarme.Wizard::SaveReportButtonClick(System.Object,System.EventArgs)
# we create but give it to cecil
M: System.Void Gendarme.Framework.Rocks.ModuleRocks::LoadDebuggingSymbols(Mono.Cecil.ModuleDefinition)

# Not sure about this one.
R: Gendarme.Rules.Design.Generic.PreferGenericsOverRefObjectRule
M: Mono.Cecil.Cil.Instruction Gendarme.Framework.Helpers.StackEntryAnalysis::GetNextInstruction(Mono.Cecil.Cil.Instruction,System.Object&)

R: Gendarme.Rules.Exceptions.UseObjectDisposedExceptionRule
M: System.Void Gendarme.Wizard::set_Current(Gendarme.Page)

R: Gendarme.Rules.Correctness.CheckParametersNullityInVisibleMethodsRule
# cannot be null - waiting for code contracts
M: System.Void Gendarme.ConsoleRunner::OnAssembly(Gendarme.Framework.RunnerEventArgs)
M: System.Void Gendarme.Framework.Runner::TearDown(Gendarme.Framework.IRule)
M: System.Void Gendarme.Rules.Concurrency.DecorateThreadsRule::OnAssembly(System.Object,Gendarme.Framework.RunnerEventArgs)
M: System.Void Gendarme.Rules.Concurrency.DoNotLockOnWeakIdentityObjectsRule::Analyze(Mono.Cecil.MethodDefinition,Mono.Cecil.MethodReference,Mono.Cecil.Cil.Instruction)
# all > 200 rules expose a Check* method that does not check for null (by contract) but we need code contracts to show this
M: Gendarme.Framework.RuleResult Gendarme.Rules.*::CheckAssembly(Mono.Cecil.AssemblyDefinition)
M: Gendarme.Framework.RuleResult Gendarme.Rules.*::CheckMethod(Mono.Cecil.MethodDefinition)
M: Gendarme.Framework.RuleResult Gendarme.Rules.*::CheckType(Mono.Cecil.TypeDefinition)

# temp entries (new rule) most need to be fixed but some occurs on different code paths
R: Gendarme.Rules.Performance.AvoidRepetitiveCallsToPropertiesRule
M: System.Int32 Gendarme.Settings::LoadRulesFromAssembly(System.String,System.String,System.String,System.String)
M: System.Boolean Gendarme.Framework.Rocks.MethodRocks::IsOverride(Mono.Cecil.MethodReference)
M: System.Void Gendarme.Rules.Concurrency.DecorateThreadsRule::CheckMethodBody(Mono.Cecil.MethodDefinition)
M: Gendarme.Framework.ThreadModel Gendarme.Rules.Concurrency.ThreadRocks::ThreadingModel(Mono.Cecil.MethodDefinition)
M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.DisposableFieldsShouldBeDisposedRule::CheckType(Mono.Cecil.TypeDefinition)
M: System.Void Gendarme.Rules.Correctness.ReviewInconsistentIdentityRule::ProcessMethod(Mono.Cecil.TypeDefinition,Gendarme.Rules.Correctness.ReviewInconsistentIdentityRule/MethodInfo)
M: System.Void Gendarme.Rules.Correctness.ReviewInconsistentIdentityRule::CheckHashMethod()
M: System.Void Gendarme.Rules.Correctness.ReviewInconsistentIdentityRule::CheckCloneMethod()
M: System.Void Gendarme.Rules.Correctness.ProvideCorrectArgumentsToFormattingMethodsRule::CheckCallToFormatter(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition)
M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.DisposableTypesShouldHaveFinalizerRule::CheckType(Mono.Cecil.TypeDefinition)
M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.Generic.DoNotExposeNestedGenericSignaturesRule::CheckMethod(Mono.Cecil.MethodDefinition)
M: System.String Gendarme.Rules.Exceptions.DoNotThrowInUnexpectedLocationRule::ExplainThrow(Mono.Cecil.Cil.Instruction)
M: System.Boolean Gendarme.Rules.Exceptions.MissingExceptionConstructorsRule::CheckForInnerExceptionConstructor(Mono.Cecil.IMethodSignature)
M: Gendarme.Framework.RuleResult Gendarme.Rules.Exceptions.MissingExceptionConstructorsRule::CheckType(Mono.Cecil.TypeDefinition)
M: System.Boolean Gendarme.Rules.Interoperability.GetLastErrorMustBeCalledRightAfterPInvokeRule::CheckPInvoke(Mono.Cecil.Cil.Instruction)
M: Mono.Cecil.TypeDefinition Gendarme.Rules.Maintainability.AvoidUnnecessarySpecializationRule::GetInterfaceImplementor(Mono.Cecil.TypeDefinition,System.Collections.Generic.IEnumerable`1<Gendarme.Framework.Helpers.MethodSignature>)
M: System.Boolean Gendarme.Rules.Maintainability.AvoidUnnecessarySpecializationRule::IsSystemObjectMethod(Mono.Cecil.MethodReference)
M: System.Void Gendarme.Rules.Maintainability.AvoidUnnecessarySpecializationRule::UpdateParameterLeastType(Mono.Cecil.ParameterReference,System.Collections.Generic.IEnumerable`1<Gendarme.Framework.Helpers.StackEntryUsageResult>)
M: Gendarme.Framework.RuleResult Gendarme.Rules.Performance.CompareWithEmptyStringEfficientlyRule::CheckMethod(Mono.Cecil.MethodDefinition)
M: System.Boolean Gendarme.Rules.Performance.DoNotIgnoreMethodResultRule::IsCallException(Mono.Cecil.MethodReference)
M: System.String Gendarme.Rules.Performance.MathMinMaxCandidateRule::GetPrevious(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction&)
M: Gendarme.Framework.RuleResult Gendarme.Rules.Serialization.DeserializeOptionalFieldRule::CheckType(Mono.Cecil.TypeDefinition)
M: Gendarme.Framework.RuleResult Gendarme.Rules.Serialization.ImplementISerializableCorrectlyRule::CheckType(Mono.Cecil.TypeDefinition)
M: Gendarme.Framework.RuleResult Gendarme.Rules.Serialization.MarkAllNonSerializableFieldsRule::CheckType(Mono.Cecil.TypeDefinition)
M: System.Void Gendarme.Wizard::Open(System.String)
M: System.Void Gendarme.Wizard::UpdateAssemblies()
M: System.Void Gendarme.Wizard::PrepareAnalyze()
M: System.Void Gendarme.Wizard::Analyze()
M: System.Void Gendarme.Wizard::UpdateReportUI()
M: Gendarme.ResultWriter Gendarme.Wizard::GetSelectedWriter(System.Int32,System.String)
# CSC only - System.Int32 System.Collections.CollectionBase::get_Count() > 20 (22) but MS.NET use an higher limit to inline...
M: System.Boolean Gendarme.Rules.Naming.ParameterNamesShouldMatchOverriddenMethodRule::SignatureMatches(Mono.Cecil.MethodReference,Mono.Cecil.MethodReference,System.Boolean)
# 'type' might be re-assigned so the second call to FullName is required
M: System.Void Gendarme.Rules.Concurrency.DoNotLockOnWeakIdentityObjectsRule::Analyze(Mono.Cecil.MethodDefinition,Mono.Cecil.MethodReference,Mono.Cecil.Cil.Instruction)
# different code path / switch
M: System.Void Gendarme.Rules.Correctness.ProvideValidXmlStringRule::CheckCall(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodReference)
M: System.Void Gendarme.Rules.Correctness.ProvideValidXPathExpressionRule::CheckCall(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodReference)
M: System.Boolean Gendarme.Rules.Concurrency.DoNotLockOnWeakIdentityObjectsRule::IsWeakSealedType(Mono.Cecil.TypeReference)

# mono bug wrt metatoken id with generics
R: Gendarme.Rules.Performance.AvoidUncalledPrivateCodeRule
M: System.Nullable`1<Gendarme.Framework.ThreadModel> Gendarme.Rules.Concurrency.ThreadRocks::Lookup(Mono.Cecil.MemberReference,System.Collections.Generic.IEnumerable`1<TDefinition>)

# mono compiler bug wrt naming autogenerated variables #660530
R: Gendarme.Rules.Performance.AvoidRepetitiveCallsToPropertiesRule
M: System.Void Gendarme.IgnoreFileList::Resolve()
M: System.Boolean Gendarme.Settings::Load()
M: System.Void Gendarme.XmlResultWriter::CreateDefects()
M: System.Void Gendarme.Framework.Engines.SuppressMessageEngine::ResolveTargets()
M: System.Collections.Generic.List`1<Gendarme.Framework.Helpers.StackEntryAnalysis/InstructionWithLeave> Gendarme.Framework.Helpers.StackEntryAnalysis::FindLoad(Gendarme.Framework.Helpers.StackEntryAnalysis/InstructionWithLeave,Gendarme.Framework.Helpers.StackEntryAnalysis/StoreSlot)
M: System.Void Gendarme.Framework.EngineController::Build(System.Collections.Generic.IList`1<Mono.Cecil.AssemblyDefinition>)
M: System.Void Gendarme.Framework.Runner::Initialize()
M: System.Void Gendarme.Framework.Runner::Run()
M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.AvoidSmallNamespaceRule::CheckAssembly(Mono.Cecil.AssemblyDefinition)
M: System.Void Gendarme.Rules.Design.AvoidSmallNamespaceRule::TearDown()
M: Gendarme.Framework.RuleResult Gendarme.Rules.Design.InternalNamespacesShouldNotExposeTypesRule::CheckAssembly(Mono.Cecil.AssemblyDefinition)
M: System.Void Gendarme.Rules.Interoperability.Com.MarkComSourceInterfacesAsIDispatchRule::FindInterfaces()
M: System.Boolean Gendarme.Rules.Smells.AvoidSpeculativeGeneralityRule::HasExpectedInheritedTypeCount(Mono.Cecil.TypeReference,System.Int32)
M: System.Void Gendarme.XmlResultWriter::CreateDefects()
M: System.Boolean Gendarme.Wizard::UpdateActiveRules()
M: System.Void Gendarme.Framework.Engines.SuppressMessageEngine::AddIgnore(Mono.Cecil.IMetadataTokenProvider,System.Collections.Generic.IEnumerable`1<System.String>)

# ---------------------------------------------------------
# We might want to fix these.

# in some cases a null and String.Empty means different things (e.g. absense versus empty)
R: Gendarme.Rules.BadPractice.PreferEmptyInstanceOverNullRule
M: System.String Gendarme.Rules.Correctness.AvoidMethodsWithSideEffectsInConditionalCodeRule::ConditionalOn(Mono.Cecil.MethodReference)
M: System.String Gendarme.Rules.Maintainability.AvoidUnnecessarySpecializationRule::GetReturnTypeSignature(Mono.Cecil.MethodReference)
T: Gendarme.Rules.Correctness.ProvideCorrectArgumentsToFormattingMethodsRule

# some needs fixing - to be reviewed
R: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSameClassRule
# StartsHandlerRegion(Mono.Cecil.Cil.Instruction) vs StartsTryRegion(Mono.Cecil.Cil.Instruction)
# EndsTryRegion(Mono.Cecil.Cil.Instruction) vs EndsHandlerRegion(Mono.Cecil.Cil.Instruction)
T: Gendarme.Framework.Helpers.MethodPrinter
# Matches(Mono.Cecil.MethodReference) vs ToString()
T: Gendarme.Framework.Helpers.MethodSignature
# GetOperand(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition) vs GetOperandType(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition)
# GetOperandType(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition) vs GetParameter(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition)
T: Gendarme.Framework.Rocks.InstructionRocks
# Implements(Mono.Cecil.TypeReference,System.String) vs Inherits(Mono.Cecil.TypeReference,System.String)
T: Gendarme.Framework.Rocks.TypeRocks
# OnType(Gendarme.Framework.RunnerEventArgs) vs OnMethod(Gendarme.Framework.RunnerEventArgs)
T: Gendarme.Framework.Runner
# GetArgumentType(Mono.Cecil.Cil.Instruction,Mono.Cecil.MethodDefinition) vs CheckMethod(Mono.Cecil.MethodDefinition)
T: Gendarme.Rules.Correctness.DoNotRoundIntegersRule
# GetPrevious(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction&) vs IsOk(Mono.Cecil.Cil.Instruction)
T: Gendarme.Rules.Performance.MathMinMaxCandidateRule
# LoadElementMatch(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction,Mono.Cecil.Cil.Instruction) vs LoadIndirectMatch(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction,Mono.Cecil.Cil.Instruction)
T: Gendarme.Rules.Performance.AvoidRepetitiveCastsRule
# CheckAssembly(Mono.Cecil.AssemblyDefinition) vs CheckMethod(Mono.Cecil.MethodDefinition)
T: Gendarme.Rules.Portability.ExitCodeIsLimitedOnUnixRule
# GetSignatures and UpdateParameterLeastType - similar loop/switch/case but cannot be merged
T: Gendarme.Rules.Maintainability.AvoidUnnecessarySpecializationRule
# CheckAssemblyForMethodUsage and GetCache - not clear, needs review
T: Gendarme.Rules.Performance.AvoidUncalledPrivateCodeRule
# CheckForAny and CheckMethod
T: Gendarme.Rules.Performance.ReviewLinqMethodRule
# CheckType and ProcessMethods, ProcessMethods and ProcessProperties
T: Gendarme.Rules.Design.StronglyTypedRule
# 2.8+
M: System.String Gendarme.Rules.Maintainability.PreferStringIsNullOrEmptyRule::GetName(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction)
# ParseSeverity(System.String) and ParseConfidence(System.String) are very similar
T: Gendarme.ConsoleRunner

R: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSiblingClassesRule
M: Gendarme.Framework.RuleResult Gendarme.Rules.Correctness.AvoidFloatingPointEqualityRule::CheckMethod(Mono.Cecil.MethodDefinition)
# CheckType and GetEngineDependencyValue
T: Gendarme.Rules.Gendarme.MissingEngineDependencyRule
# DoNotThrowExceptionRule::CheckMethod and MissingEngineDependencyRule::CheckType
T: Gendarme.Rules.Gendarme.GendarmeRule

R: Gendarme.Rules.Smells.AvoidSpeculativeGeneralityRule
T: Gendarme.Framework.EngineController
T: Gendarme.Framework.Helpers.MethodSignatures
T: Gendarme.Framework.Rocks.ParameterRocks

# FIXME - note: some seems to be related to an xMCS bug
R: Gendarme.Rules.Performance.AvoidMethodWithLargeMaximumStackSizeRule
# Found 1110 maximum stack size (maximum 100). ### autogenerated - should be ignored
M: System.Void Gendarme.Wizard::InitializeComponent()
# Found 129 maximum stack size (maximum 100).
M: System.Collections.Generic.List`1<Gendarme.Framework.Helpers.StackEntryAnalysis/InstructionWithLeave> Gendarme.Framework.Helpers.StackEntryAnalysis::FindLoad(Gendarme.Framework.Helpers.StackEntryAnalysis/InstructionWithLeave,Gendarme.Framework.Helpers.StackEntryAnalysis/StoreSlot)
# Found 202 maximum stack size (maximum 100).
M: System.Void Gendarme.Rules.Concurrency.DecorateThreadsRule::CheckMethodBody(Mono.Cecil.MethodDefinition)
# Found 121 maximum stack size (maximum 100).
M: System.Void Gendarme.Rules.Correctness.ReviewInconsistentIdentityRule::ProcessMethod(Mono.Cecil.TypeDefinition,Gendarme.Rules.Correctness.ReviewInconsistentIdentityRule/MethodInfo)
# Found 188 maximum stack size (maximum 100).

# FIXME
R: Gendarme.Rules.Maintainability.AvoidComplexMethodsRule
# CC 32
M: System.Void Gendarme.Framework.Helpers.MethodSignatures::.cctor()
# CC 29
M: System.Collections.Generic.List`1<Gendarme.Framework.Helpers.StackEntryAnalysis/InstructionWithLeave> Gendarme.Framework.Helpers.StackEntryAnalysis::FindLoad(Gendarme.Framework.Helpers.StackEntryAnalysis/InstructionWithLeave,Gendarme.Framework.Helpers.StackEntryAnalysis/StoreSlot)
# CC 43
M: System.Void Gendarme.Rules.Concurrency.DecorateThreadsRule::CheckMethodBody(Mono.Cecil.MethodDefinition)
# CC 41
M: Gendarme.Framework.RuleResult Gendarme.Rules.Concurrency.DecorateThreadsRule::CheckMethod(Mono.Cecil.MethodDefinition)

# FIXME
R: Gendarme.Rules.Smells.AvoidLongMethodsRule
# Logical SLOC: 50. Maximum : 40
M: System.Collections.Generic.List`1<Gendarme.Framework.Helpers.StackEntryAnalysis/InstructionWithLeave> Gendarme.Framework.Helpers.StackEntryAnalysis::FindLoad(Gendarme.Framework.Helpers.StackEntryAnalysis/InstructionWithLeave,Gendarme.Framework.Helpers.StackEntryAnalysis/StoreSlot)
# Logical SLOC: 64. Maximum : 40
M: System.Void Gendarme.Rules.Concurrency.DecorateThreadsRule::CheckMethodBody(Mono.Cecil.MethodDefinition)

# some fixes possible, needs to be reviewed
R: Gendarme.Rules.Maintainability.AvoidLackOfCohesionOfMethodsRule
T: Gendarme.ConsoleRunner
T: Gendarme.Settings
T: Gendarme.Framework.Helpers.MethodPrinter
T: Gendarme.Framework.Helpers.MethodSignature
T: Gendarme.Framework.Defect
T: Gendarme.Framework.EngineController
T: Gendarme.Rules.Concurrency.DecorateThreadsRule
T: Gendarme.Rules.Correctness.ReviewInconsistentIdentityRule
T: Gendarme.Rules.Correctness.ReviewInconsistentIdentityRule/MethodInfo
T: Gendarme.Rules.Globalization.SatelliteResourceMismatchRule/AssemblyResourceCache
T: Gendarme.Rules.Interoperability.DelegatesPassedToNativeCodeMustIncludeExceptionHandlingRule
T: Gendarme.Rules.Interoperability.UseManagedAlternativesToPInvokeRule/ManagedAlternatives
T: Gendarme.Rules.Maintainability.AvoidComplexMethodsRule
T: Gendarme.Rules.Maintainability.AvoidLackOfCohesionOfMethodsRule
T: Gendarme.Rules.Portability.MonoCompatibilityReviewRule
T: Gendarme.Rules.Smells.AvoidLongMethodsRule
T: Gendarme.Rules.Smells.CodeDuplicatedLocator
T: Gendarme.Rules.Smells.Pattern
T: Gendarme.GuiRunner
T: Gendarme.Wizard

# BUG - suggestion won't compile - two different, incompatible interfaces are used IMethodSignature and IMetadataTokenProvider
# rule suggest the first one (same depth) but since it cannot be casted it should propose a base class
R: Gendarme.Rules.Maintainability.AvoidUnnecessarySpecializationRule
M: System.Boolean Gendarme.Rules.Interoperability.Com.ComRocks::IsTypeComVisible(Mono.Cecil.TypeDefinition)
M: System.Boolean Gendarme.Rules.Performance.AvoidUnnecessaryOverridesRule::IsBase(Mono.Cecil.MethodReference,Mono.Cecil.MethodReference)
M: System.Boolean Gendarme.Rules.Correctness.BadRecursiveInvocationRule::CompareMethods(Mono.Cecil.MethodReference,Mono.Cecil.MethodReference,System.Boolean)
M: System.Boolean Gendarme.Rules.Naming.ParameterNamesShouldMatchOverriddenMethodRule::SignatureMatches(Mono.Cecil.MethodReference,Mono.Cecil.MethodReference,System.Boolean)

# ---------------------------------------------------------
# These are all OK.

# OK - The rule itself needs the literal new line characters to test against them
R: Gendarme.Rules.Portability.NewLineLiteralRule
M: Gendarme.Framework.RuleResult Gendarme.Rules.Portability.NewLineLiteralRule::CheckMethod(Mono.Cecil.MethodDefinition)

# OK - don't apply the rule to itself
R: Gendarme.Rules.Portability.DoNotHardcodePathsRule
M: System.Void Gendarme.Rules.Portability.DoNotHardcodePathsRule::ProcessUnixProbablyAbsolutePath(System.String)

# OK - in those case the specialization has its contextual sense and helps readability
R: Gendarme.Rules.Maintainability.AvoidUnnecessarySpecializationRule
M: System.Boolean Gendarme.Framework.Rocks.ModuleRocks::HasDebuggingInformation(Mono.Cecil.ModuleDefinition)
M: System.Void Gendarme.Framework.Defect::.ctor(Gendarme.Framework.IRule,Mono.Cecil.IMetadataTokenProvider,Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction,Gendarme.Framework.Severity,Gendarme.Framework.Confidence,System.String)
# only applies to parameters, so using 'Mono.Cecil.ICustomAttributeProvider' would only be confusing (e.g. code completion)
M: System.Boolean Gendarme.Framework.Rocks.ParameterRocks::IsParams(Mono.Cecil.ParameterDefinition)
# the bitmask applies only to methods, so using 'Mono.Cecil.IAnnotationProvider' would only be confusing (e.g. code completion)
M: Gendarme.Framework.Helpers.OpCodeBitmask Gendarme.Framework.Engines.OpCodeEngine::GetBitmask(Mono.Cecil.MethodDefinition)
# the check is done on methods, so using 'Mono.Cecil.IMemberReference' would only be confusing (e.g. code completion)
M: System.Boolean Gendarme.Framework.Rocks.MethodRocks::IsEntryPoint(Mono.Cecil.MethodReference)
# the check is done on types so using the suggested 'Mono.Cecil.MemberReference' would be confusing (e.g. code completion)
M: System.Boolean Gendarme.Framework.Rocks.TypeRocks::IsFloatingPoint(Mono.Cecil.TypeReference)
M: System.Boolean Gendarme.Framework.Rocks.TypeRocks::IsNative(Mono.Cecil.TypeReference)

# OK - the gendarme framework is not a beginner, nor easy, API
R: Gendarme.Rules.Design.AvoidRefAndOutParametersRule
M: Mono.Cecil.Cil.Instruction Gendarme.Framework.Helpers.StackEntryAnalysis::GetNextInstruction(Mono.Cecil.Cil.Instruction,System.Object&)

# OK - the field is not owned by this type
R: Gendarme.Rules.Design.TypesWithDisposableFieldsShouldBeDisposableRule
T: Gendarme.GuiRunner

# OK - the framework and the runners each have a global catch all to report errors
R: Gendarme.Rules.Exceptions.DoNotSwallowErrorsCatchingNonSpecificExceptionsRule
M: System.Byte Gendarme.ConsoleRunner::Execute(System.String[])
M: System.Void Gendarme.Framework.Runner::Initialize()
M: System.Void Gendarme.GuiRunner::Execute()
# OK - DelegatesPassedToNativeCodeMustIncludeExceptionHandlingRule might throw exceptions with very uncommon code sequences (obfuscated code for instance)
M: Gendarme.Framework.RuleResult Gendarme.Rules.Interoperability.DelegatesPassedToNativeCodeMustIncludeExceptionHandlingRule::CheckMethod(Mono.Cecil.MethodDefinition)
# FIXME the last one needs validation
M: System.Boolean Gendarme.Wizard::CouldCopyReport(System.String&,System.String)

# OK - MethodSignatures use the CLR names for operators that starts with "op_"
R: Gendarme.Rules.Naming.AvoidNonAlphanumericIdentifierRule
T: Gendarme.Framework.Helpers.MethodSignatures

# OK - IMethodRule is not declared on purpose on BadPractice.ReturnNullRule
R: Gendarme.Rules.Design.ConsiderAddingInterfaceRule
T: Gendarme.Rules.BadPractice.ReturnNullRule

# OK - RegEx sadly do not provide a TryPattern method
R: Gendarme.Rules.Performance.DoNotIgnoreMethodResultRule
M: System.Boolean Gendarme.Rules.Correctness.ProvideCorrectRegexPatternRule::CheckPattern(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction,System.String,Gendarme.Framework.Confidence)

# OK - The set of potential exceptions of RegEx is unknown
R: Gendarme.Rules.Exceptions.DoNotSwallowErrorsCatchingNonSpecificExceptionsRule
M: System.Boolean Gendarme.Rules.Correctness.ProvideCorrectRegexPatternRule::CheckPattern(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction,System.String,Gendarme.Framework.Confidence)

# OK - we're using switch extensively and in a way that would be hard to OO-ize while keeping performance and readability
R: Gendarme.Rules.Smells.AvoidSwitchStatementsRule
A: *

# OK - small, but slowly growing, namespace
R: Gendarme.Rules.Design.AvoidSmallNamespaceRule
N: Gendarme.Framework.Engines

# The winforms wizard uses Gendarme from a thread so the DecorateThreadsRule will
# fire because Gendarme code, like the rules and the runners, are not marked as
# thread-safe.
R: Gendarme.Rules.Concurrency.DecorateThreadsRule
M: System.Void Gendarme.Wizard::UpdateWelcomeUI()
M: System.Boolean Gendarme.Wizard::UpdateActiveRules()
M: System.Void Gendarme.Wizard::Analyze()

# This is internal code.
R: Gendarme.Rules.Performance.AvoidReturningArraysOnPropertiesRule
M: System.Int32[] Gendarme.Rules.Smells.Pattern::get_Prefixes()

# OK - GetFastCyclomaticComplexity and GetSwitchCyclomaticComplexity are meant to be similar
R: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSameClassRule
T: Gendarme.Rules.Maintainability.AvoidComplexMethodsRule

# OK - some field prefix are identical - but they would be hard to avoid while keeping readability
R: Gendarme.Rules.Smells.AvoidLargeClassesRule
T: Gendarme.Wizard
T: Gendarme.Framework.Helpers.OpCodeBitmask
T: Gendarme.Framework.Runner

# Conditional code is used and, sadly, this leaves useless control flow in the IL
R: Gendarme.Rules.Correctness.ReviewUselessControlFlowRule
M: System.Void Gendarme.Framework.Helpers.Log::WriteLine(T)
M: System.Void Gendarme.Framework.Helpers.Log::WriteLine(T,System.String,System.Object[])
M: System.Void Gendarme.Framework.Helpers.Log::WriteLine(T,Mono.Cecil.MethodDefinition)
M: System.Void Gendarme.Framework.Helpers.Log::WriteLine(System.String)
M: System.Void Gendarme.Framework.Helpers.Log::WriteLine(System.String,System.String,System.Object[])
M: System.Void Gendarme.Framework.Helpers.Log::WriteLine(System.String,Mono.Cecil.MethodDefinition)

# some methods call [Conditional] code where 'this' is used so the compiler can't accept a static method. However the compiled IL could be static
R: Gendarme.Rules.Correctness.MethodCanBeMadeStaticRule
M: System.String Gendarme.Rules.Correctness.AvoidCodeWithSideEffectsInConditionalCodeRule::Mutates(Mono.Cecil.MethodDefinition,Mono.Cecil.Cil.Instruction)
M: System.Boolean Gendarme.Rules.Correctness.AvoidMethodsWithSideEffectsInConditionalCodeRule::IsPure(Mono.Cecil.MethodReference)

R: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSameClassRule
# OK - (CSC only) GetLoadSlot and GetStoreSlot are identical except for the switch/case (load versus store instructions) - delegating calls won't change defect
T: Gendarme.Framework.Helpers.StackEntryAnalysis

# OK
R: Gendarme.Rules.Naming.AvoidRedundancyInTypeNameRule
# ComRocks is not directly used
T: Gendarme.Rules.Interoperability.Com.ComRocks
# Some Com rules start with 'Com'
T: Gendarme.Rules.Interoperability.Com.ComVisibleShouldInheritFromComVisibleRule
T: Gendarme.Rules.Interoperability.Com.ComVisibleTypesShouldBeCreatableRule
# NUnitRocks is not directly used
T: Gendarme.Rules.NUnit.NUnitRocks

# OK - different code paths
R: Gendarme.Rules.Performance.AvoidRepetitiveCastsRule
M: System.Boolean Gendarme.Rules.Security.Cas.SecurityDeclarationRocks::TryProcessPermissionSetAttribute(Mono.Cecil.SecurityDeclaration,System.Security.PermissionSet&)
R: Gendarme.Rules.Performance.AvoidUnneededUnboxingRule
M: System.Boolean Gendarme.Rules.Security.Cas.SecurityDeclarationRocks::TryProcessPermissionSetAttribute(Mono.Cecil.SecurityDeclaration,System.Security.PermissionSet&)

# OK - Runner.Report is being called in a base type or in another type (for Smells)
R: Gendarme.Rules.Gendarme.DefectsMustBeReportedRule
T: Gendarme.Rules.Design.EnumeratorsShouldBeStronglyTypedRule
T: Gendarme.Rules.Design.StronglyTypeICollectionMembersRule
T: Gendarme.Rules.Design.ListsAreStronglyTypedRule
T: Gendarme.Rules.Design.MarkAssemblyWithComVisibleRule
T: Gendarme.Rules.Design.MarkAssemblyWithCLSCompliantRule
T: Gendarme.Rules.Exceptions.DoNotThrowReservedExceptionRule
T: Gendarme.Rules.Exceptions.AvoidThrowingBasicExceptionsRule
T: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSiblingClassesRule
T: Gendarme.Rules.Smells.AvoidCodeDuplicatedInSameClassRule
T: Gendarme.Rules.UI.SystemWindowsFormsExecutableTargetRule
T: Gendarme.Rules.UI.GtkSharpExecutableTargetRule

# OK - Gendarme.Framework.Rule may throw exceptions as it is not a real rule
R: Gendarme.Rules.Gendarme.DoNotThrowExceptionRule
T: Gendarme.Framework.Rule

# Type::op_[Ine|e]quality is new and marked as MonoTODO but it does (at least) the same job as the earlier FX provided
R: Gendarme.Rules.Portability.MonoCompatibilityReviewRule
M: System.Void Gendarme.Framework.Rocks.ModuleRocks::LoadDebuggingSymbols(Mono.Cecil.ModuleDefinition)
M: System.Void Gendarme.Framework.Rocks.ModuleRocks::.cctor()
M: System.Void Gendarme.Framework.EngineDependencyAttribute::.ctor(System.Type)
M: System.Type Gendarme.Framework.Rule::get_Type()
M: System.Security.IPermission Gendarme.Rules.Security.Cas.SecurityDeclarationRocks::CreatePermission(Mono.Cecil.SecurityDeclaration,Mono.Cecil.SecurityAttribute)

