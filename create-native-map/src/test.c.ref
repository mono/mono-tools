/*
 * This file was automatically generated by create-native-map from TestMap.dll.
 *
 * DO NOT MODIFY.
 */
#ifdef HAVE_CONFIG_H
#include <config.h>
#endif /* ndef HAVE_CONFIG_H */

#include <stdlib.h>
#include <string.h>

/*
 * Implementation Macros
 */
#ifndef FOO
#define FOO "foo"
#endif /* ndef FOO */


/*
 * Implementation Includes
 */
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif /* ndef HAVE_UNISTD_H */
#include <stdio.h>
#include "foo.h"

#include "test.h"

#include <errno.h>    /* errno, EOVERFLOW */
#include <glib.h>     /* g* types, g_assert_not_reached() */

/* returns TRUE if @type is an unsigned type */
#define _cnm_integral_type_is_unsigned(type) \
    (sizeof(type) == sizeof(gint8)           \
      ? (((type)-1) > G_MAXINT8)             \
      : sizeof(type) == sizeof(gint16)       \
        ? (((type)-1) > G_MAXINT16)          \
        : sizeof(type) == sizeof(gint32)     \
          ? (((type)-1) > G_MAXINT32)        \
          : sizeof(type) == sizeof(gint64)   \
            ? (((type)-1) > G_MAXINT64)      \
            : (g_assert_not_reached (), 0))

/* returns the minimum value of @type as a gint64 */
#define _cnm_integral_type_min(type)          \
    (_cnm_integral_type_is_unsigned (type)    \
      ? 0                                     \
      : sizeof(type) == sizeof(gint8)         \
        ? G_MININT8                           \
        : sizeof(type) == sizeof(gint16)      \
          ? G_MININT16                        \
          : sizeof(type) == sizeof(gint32)    \
            ? G_MININT32                      \
            : sizeof(type) == sizeof(gint64)  \
              ? G_MININT64                    \
              : (g_assert_not_reached (), 0))

/* returns the maximum value of @type as a guint64 */
#define _cnm_integral_type_max(type)            \
    (_cnm_integral_type_is_unsigned (type)      \
      ? sizeof(type) == sizeof(gint8)           \
        ? G_MAXUINT8                            \
        : sizeof(type) == sizeof(gint16)        \
          ? G_MAXUINT16                         \
          : sizeof(type) == sizeof(gint32)      \
            ? G_MAXUINT32                       \
            : sizeof(type) == sizeof(gint64)    \
              ? G_MAXUINT64                     \
              : (g_assert_not_reached (), 0)    \
      : sizeof(type) == sizeof(gint8)           \
          ? G_MAXINT8                           \
          : sizeof(type) == sizeof(gint16)      \
            ? G_MAXINT16                        \
            : sizeof(type) == sizeof(gint32)    \
              ? G_MAXINT32                      \
              : sizeof(type) == sizeof(gint64)  \
                ? G_MAXINT64                    \
                : (g_assert_not_reached (), 0))

#ifdef DEBUG
#define _cnm_dump_(to_t,from)                                            \
  printf ("# %s -> %s: min=%llx; max=%llx; value=%llx; lt=%i; l0=%i; gt=%i; e=%i\n", \
    #from, #to_t,                                                        \
    (gint64) (_cnm_integral_type_min(to_t)),                             \
    (gint64) (_cnm_integral_type_max (to_t)),                            \
    (gint64) (from),                                                     \
    (_cnm_integral_type_min (to_t) <= from),                             \
    (from < 0),                                                          \
    /* (_cnm_integral_type_max (to_t) >= from) */                        \
    (from <= _cnm_integral_type_max (to_t)),                             \
    ((_cnm_integral_type_min(to_t) >= from) &&                           \
          ((from < 0) ? 1 : (from <= _cnm_integral_type_max(to_t))))     \
  )
#else
#define _cnm_dump_(to_t, from) do {} while (0)
#endif

#define _cnm_return_val_if_overflow(to_t,from,val)  G_STMT_START {   \
    if (!(_cnm_integral_type_min(to_t) <= from &&                    \
          ((from < 0) || (from <= _cnm_integral_type_max(to_t))))) { \
      _cnm_dump_(to_t, from);                                        \
      errno = EOVERFLOW;                                             \
      return (val);                                                  \
    }                                                                \
  } G_STMT_END

int
MakeMap_Test_FromFoo (struct MakeMap_Test_Foo *from, struct foo *to)
{
	_cnm_return_val_if_overflow (int, from->foo, -1);
#ifdef HAVE_STRUCT_FOO_AUTOCONF_ME
	_cnm_return_val_if_overflow (gint64, from->autoconf_me, -1);
#endif /* ndef HAVE_STRUCT_FOO_AUTOCONF_ME */

	memset (to, 0, sizeof(*to));

	to->foo         = from->foo;
	to->p           = from->p;
#ifdef HAVE_STRUCT_FOO_AUTOCONF_ME
	to->autoconf_me = from->autoconf_me;
#endif /* ndef HAVE_STRUCT_FOO_AUTOCONF_ME */

	return 0;
}


int
MakeMap_Test_ToFoo (struct foo *from, struct MakeMap_Test_Foo *to)
{
	_cnm_return_val_if_overflow (int, from->foo, -1);
#ifdef HAVE_STRUCT_FOO_AUTOCONF_ME
	_cnm_return_val_if_overflow (gint64, from->autoconf_me, -1);
#endif /* ndef HAVE_STRUCT_FOO_AUTOCONF_ME */

	memset (to, 0, sizeof(*to));

	to->foo         = from->foo;
	to->p           = from->p;
#ifdef HAVE_STRUCT_FOO_AUTOCONF_ME
	to->autoconf_me = from->autoconf_me;
#endif /* ndef HAVE_STRUCT_FOO_AUTOCONF_ME */

	return 0;
}


int
MakeMap_Test_FromFooHolder (struct MakeMap_Test_FooHolder *from, struct foo_holder *to)
{

	memset (to, 0, sizeof(*to));

	if (MakeMap_Test_FromFoo (&from->foo, &to->foo) != 0) {
		return -1;
	}
	if (MakeMap_Test_FromTestEnum (from->mode, &to->mode) != 0) {
		return -1;
	}

	return 0;
}


int
MakeMap_Test_ToFooHolder (struct foo_holder *from, struct MakeMap_Test_FooHolder *to)
{

	memset (to, 0, sizeof(*to));

	if (MakeMap_Test_ToFoo (&from->foo, &to->foo) != 0) {
		return -1;
	}
	if (MakeMap_Test_ToTestEnum (from->mode, &to->mode) != 0) {
		return -1;
	}

	return 0;
}


int MakeMap_Test_FromTestEnum (int x, int *r)
{
	*r = 0;
	if (x == MakeMap_Test_TestEnum_Bar)
#ifdef Bar
		{*r = Bar; return 0;}
#else /* def Bar */
		{errno = EINVAL; return -1;}
#endif /* ndef Bar */
	if (x == MakeMap_Test_TestEnum_Baz)
#ifdef Baz
		{*r = Baz; return 0;}
#else /* def Baz */
		{errno = EINVAL; return -1;}
#endif /* ndef Baz */
	if (x == MakeMap_Test_TestEnum_Foo)
#ifdef Foo
		{*r = Foo; return 0;}
#else /* def Foo */
		{errno = EINVAL; return -1;}
#endif /* ndef Foo */
	if (x == MakeMap_Test_TestEnum_Qux)
#ifdef Qux
		{*r = Qux; return 0;}
#else /* def Qux */
		{errno = EINVAL; return -1;}
#endif /* ndef Qux */
	if (x == 0)
		return 0;
	errno = EINVAL; return -1;
}

int MakeMap_Test_ToTestEnum (int x, int *r)
{
	*r = 0;
	if (x == 0)
		return 0;
#ifdef Bar
	if (x == Bar)
		{*r = MakeMap_Test_TestEnum_Bar; return 0;}
#endif /* ndef Bar */
#ifdef Baz
	if (x == Baz)
		{*r = MakeMap_Test_TestEnum_Baz; return 0;}
#endif /* ndef Baz */
#ifdef Foo
	if (x == Foo)
		{*r = MakeMap_Test_TestEnum_Foo; return 0;}
#endif /* ndef Foo */
#ifdef Qux
	if (x == Qux)
		{*r = MakeMap_Test_TestEnum_Qux; return 0;}
#endif /* ndef Qux */
	errno = EINVAL; return -1;
}

int MakeMap_Rename_FromColors (int x, int *r)
{
	*r = 0;
	if (x == MakeMap_Rename_Colors_Blue)
#ifdef Blue
		{*r = Blue; return 0;}
#else /* def Blue */
		{errno = EINVAL; return -1;}
#endif /* ndef Blue */
	if (x == MakeMap_Rename_Colors_Green)
#ifdef Green
		{*r = Green; return 0;}
#else /* def Green */
		{errno = EINVAL; return -1;}
#endif /* ndef Green */
	if (x == MakeMap_Rename_Colors_Red)
#ifdef Red
		{*r = Red; return 0;}
#else /* def Red */
		{errno = EINVAL; return -1;}
#endif /* ndef Red */
	if (x == 0)
		return 0;
	errno = EINVAL; return -1;
}

int MakeMap_Rename_ToColors (int x, int *r)
{
	*r = 0;
	if (x == 0)
		return 0;
#ifdef Blue
	if (x == Blue)
		{*r = MakeMap_Rename_Colors_Blue; return 0;}
#endif /* ndef Blue */
#ifdef Green
	if (x == Green)
		{*r = MakeMap_Rename_Colors_Green; return 0;}
#endif /* ndef Green */
#ifdef Red
	if (x == Red)
		{*r = MakeMap_Rename_Colors_Red; return 0;}
#endif /* ndef Red */
	errno = EINVAL; return -1;
}

